// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                            String     @id @default(cuid())
  immutableId                   String     @unique()
  nickname                      String     @unique()
  passwordHash                  String
  createdAt                     DateTime   @default(now())
  updatedAt                     DateTime   @updatedAt
  status                        UserStatus @default(OFFLINE)
  avatarImg                     String?
  eloScore                      Int        @default(0)
  twoFactorAuthenticationSet    Boolean    @default(false)
  twoFactorAuthenticationSecret String     @default("")

  friendsRequester Friendship[]      @relation("requester")
  friendsAddressee Friendship[]      @relation("addressee")
  playerOnMatches  UserMatch[]       @relation("player")
  achievements     UserAchievement[] @relation("userAchievements")
  messagesSent     Message[]         @relation("messageSender")
  userOnChannels   ChannelUser[]     @relation("userOnChannel")
  banRequester     Ban[]             @relation("banRequester")
  bannedUser       Ban[]             @relation("bannedUser")

  @@map("users")
}

model Friendship {
  requesterId String
  requester   User   @relation("requester", fields: [requesterId], references: [id], onDelete: Cascade)
  addresseeId String
  addressee   User   @relation("addressee", fields: [addresseeId], references: [id], onDelete: Cascade)

  status    FriendshipStatus @default(REQUESTED)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@id([requesterId, addresseeId])
  @@unique(fields: [requesterId, addresseeId], name: "friendshipId")
  @@map("friendships")
}

model Match {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  match UserMatch[] @relation("match")

  @@map("matches")
}

model UserMatch {
  playerId String
  player   User   @relation("player", fields: [playerId], references: [id], onDelete: Cascade)
  matchId  String
  match    Match  @relation("match", fields: [matchId], references: [id], onDelete: Cascade)
  score    Json   @default("{\"myself\" : 0, \"opponent\" : 0}")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([playerId, matchId])
  @@unique([playerId, matchId])
  @@map("user_matches")
}

model Achievement {
  id          String            @id @default(cuid())
  achievement UserAchievement[] @relation("userAchievement")
  label       String
  image       String?

  @@map("achievements")
}

model UserAchievement {
  userId        String
  user          User        @relation("userAchievements", fields: [userId], references: [id], onDelete: Cascade)
  achievementId String
  achievement   Achievement @relation("userAchievement", fields: [achievementId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([userId, achievementId])
  @@unique([userId, achievementId])
  @@map("user_achievements")
}

model Channel {
  id           String      @id @default(cuid())
  name         String      @unique
  type         ChannelType @default(PUBLIC)
  passwordHash String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages    Message[]     @relation("channelMessage")
  users       ChannelUser[] @relation("channelUsers")
  channelBans Ban[]         @relation("banOnChannel")

  @@map("channels")
}

model Message {
  id      String @id @default(cuid())
  content String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  senderId  String
  sender    User    @relation("messageSender", fields: [senderId], references: [id], onDelete: Cascade)
  channelId String
  channel   Channel @relation("channelMessage", fields: [channelId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model ChannelUser {
  userId    String
  user      User    @relation("userOnChannel", fields: [userId], references: [id], onDelete: Cascade)
  channelId String
  channel   Channel @relation("channelUsers", fields: [channelId], references: [id], onDelete: Cascade)

  role      ChannelRole @default(USER)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@id([userId, channelId])
  @@map("channel_users")
}

model Ban {
  bannedUserId String
  bannedUser   User    @relation("bannedUser", fields: [bannedUserId], references: [id], onDelete: Cascade)
  banChannelId String
  banChannel   Channel @relation("banOnChannel", fields: [banChannelId], references: [id], onDelete: Cascade)

  banRequesterId String?
  banRequester   User?   @relation("banRequester", fields: [banRequesterId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([bannedUserId, banChannelId])
  @@unique([bannedUserId, banChannelId])
  @@map("bans")
}

enum FriendshipStatus {
  REQUESTED
  ACCEPTED
}

enum ChannelType {
  PUBLIC
  PRIVATE
  PROTECTED
  DIRECTMESSAGE
}

enum UserStatus {
  OFFLINE
  ONLINE
  PLAYING
}

enum ChannelRole {
  USER
  ADMIN
  OWNER
}
